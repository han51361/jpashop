## MEMO



- 양방향 관계에 연관관계의 주인 정하기 
    - `외래키가 있는 곳을 연관관계의 주인으로 하라 `
    
- Getter는 열어두고 Setter는 꼭 필요한 경우에만 사용하라(추천)
    - getter는 아무리 호출해도 호출하는 것으로 어떤 일이 발생하지 않는다.
    - setter 는 호출하면 데이터가 변한다.
        - 따라서 setter를 막 열어두면 나중에 엔티티가 도데체 왜 변경되는지 추적하기 힘들다.

- 실무에선 @ManyToMany 사용 절대 금지


- ## `모든 연관관계는 지연로딩으로 설정해라!!!!`
    - 즉시로딩(EAGER) 은 예측이 어렵고 어떤 SQL이 실행되었는지 추적이 어렵다. (특히 JPQL을 실행할 떄 N+1문제가 자주 발생)
    - 실무에선 모든 연관관계는 지연로딩 (`LAZY`)으로 설정해야한다.
    - 연관된 엔티티를 함꼐 DB에서 조회해야한다면, fetch join or 엔티티 그래프 기능을 사용하자 
    - `####@XToOne 관계`는 기본이 즉시로딩이므로 `직접 지연로딩으로 설정`해야한다. 
    
- ### 컬렉션은 필드에서 초기화 하자
    - Null 문제에서 안전하다
    - 하이버네이트는 엔티티를 영속화할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 
    만약 getOrders() 처럼 임의의 메서드에서 컬렉션을 잘못생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 
    
        - em.persist(-); // 영속화시키는 것  -> DB에 저장하겟다. 
    
- ### 테이블, 컬럼명 생성 전략
    - 카멜 케이스  -> 언더스코어 (memberPoint -> member_point)
    - .(점) -> _(언더스코어)
    - 대문자 -> 소문자
    
    < 논리명 생성(ImplicitNamingStrategy)>  : 테이블 이나 컬럼명을 명시하지 않을 때 논리명 적용
                                                                                                                         
    <물리명 생성(physical-strategy)> : 모든 논리명에 적용됨, 실제 테이블에 적용 (username -> usernm ) 
                                                                                                
   
   ## 애플리케이션 아키텍쳐
   
  - #### 계층형 구조 사용
    - controller , web : 웹 계층
    - service : 비즈니스 로직, 트랜잭션 처리
    - repository : JPA 를 직접 사용하는 계층, 엔티티 매니저 사용
    - domain : 엔티티가 모여 있는 계층 , 모든 계층에서 접근 및 사
    - #### 단방향 구조 : Controller -> Service -> Repository -> DB  
        - (Controller 에서 Repository 바로 접근 가능)               
        
  - Garbage Collection
  
  - 테스트를 진행할 때는 단위 테스트를 하는 것이 좋다
    - 자체에 대해서 Mocking을 하고 테스트를 진행해야 더 좋다.    
    - Domain 모델 패턴 => 장점 : repository 관계 없이 엔티티에 대해 바로 테스트를 작성할 수 있다.
        - 자체 메소드가 작동하는지 DB와 관계없이 단위테스트 가능                                                                                                                                                                                                                                             


 - ### JPA 에서 동적 Query 해결하기 
    
    - ~~강의는 들었으나 아직 실제로 해본 적은 없어서 쉽게 와닿지 않는다.~~ 
    - ~~동적 쿼리 해결에 대한 모듈들의 메소드들을 정확히 다룰 줄 모르겟다.~~ 
    
    
- #### 폼 객체 vs 엔티티 직접 사용


> 참고: 

>요구사항이 정말 단순할 때는 폼 객체( MemberForm ) 없이 엔티티( Member )를 직접 등록과 수정 화면
에서 사용해도 된다. 

>하지만 화면 요구사항이 복잡해지기 시작하면, 엔티티에 화면을 처리하기 위한 기능이 점점 증가한다. 결과적으로 엔티티는 점점 화면에 종속적으로 변하고, 이렇게 화면 기능 때문에 지저분해진 엔티티는 결국 유지보수하기 어려워진다.


> 실무에서 엔티티는 핵심 비즈니스 로직만 가지고 있고, 화면을 위한 로직은 없어야 한다. 화면이나 API에 맞 는 폼 객체나 DTO를 사용하자. 그래서 화면이나 API 요구사항을 이것들로 처리하고, 엔티티는 최대한 순수 하게 유지하자.됨


>` API 를  만들 때는, 엔티티를 외부로 반환해선 안된다. (문제 :PW 노출 / API 스펙 변됨)`


- ### 변경 감지와 병합(merge)

    - 준영속 엔티티
        : 영속성 컨텍스트가 더는 관리하지 않는 엔티티
    - 준영속 엔티티를 수정하는 방법
        1. 변경 감지 기능 사용
        2. 병합(merge) 사용 
    
    - #### 병합 동작 방식
    
    1. merge()실행(member가 준영속상태 엔티티)
    2. 파라미터로 넘어온 준영속 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회한다. 
    
        1.  만약 1차 캐시에서 엔티티가 없으면 Db에서 엔티티 조회 후 , 1차 캐시에 저장
    3. 조회한 영속 엔티티(mergeMember- DB에서 가져온 놈)에 member 엔티티 값을 채워넣는다. 
    4. 영속상태인 mergeMember를 반환
    
    - #### 병합시 동작 방식 정리
    
    1. 준영속 엔티티의 식별자 값으로 영속 엔티티 조회
    2. 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체(병합)
    3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작하여 데이터베이스에 UPDATE SQL이 실행
    
    
   
    * 주의 : 변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다. 
    병합시, 값이 없으면 null 로 업데이트할 위험이 있다.(병합은 모든 필드를 교체한다.)
    
   - #### 엔티티를 변경할 때는 항상 변경감지를 이용하라! 
    - 컨트롤러에서 어설프게 엔티티를 생성하지 마라
    - 트랜잭션이 있는 서비스 계층에 식별자와 변경할 데이터를명확하게 전달하라(파람 or dto)
    - 트랜잭션이 있는 서비스 게ㅡ쳉에서 영속 상태의 엔티티를 조회하고, 엔티티의 데이터를 직접 변경하라
    