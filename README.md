## MEMO



- 양방향 관계에 연관관계의 주인 정하기 
    - `외래키가 있는 곳을 연관관계의 주인으로 하라 `
    
- Getter는 열어두고 Setter는 꼭 필요한 경우에만 사용하라(추천)
    - getter는 아무리 호출해도 호출하는 것으로 어떤 일이 발생하지 않는다.
    - setter 는 호출하면 데이터가 변한다.
        - 따라서 setter를 막 열어두면 나중에 엔티티가 도데체 왜 변경되는지 추적하기 힘들다.

- 실무에선 @ManyToMany 사용 절대 금지


- ## `모든 연관관계는 지연로딩으로 설정해라!!!!`
    - 즉시로딩(EAGER) 은 예측이 어렵고 어떤 SQL이 실행되었는지 추적이 어렵다. (특히 JPQL을 실행할 떄 N+1문제가 자주 발생)
    - 실무에선 모든 연관관계는 지연로딩 (`LAZY`)으로 설정해야한다.
    - 연관된 엔티티를 함꼐 DB에서 조회해야한다면, fetch join or 엔티티 그래프 기능을 사용하자 
    - ####@XToOne 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야한다. 
    
- ### 컬렉션은 필드에서 초기화 하자
    - Null 문제에서 안전하다
    - 하이버네이트는 엔티티를 영속화할 때, 컬렉션을 감싸서 하이버네이트가 제공하는 내장 컬렉션으로 변경한다. 
    만약 getOrders() 처럼 임의의 메서드에서 컬렉션을 잘못생성하면 하이버네이트 내부 메커니즘에 문제가 발생할 수 있다. 
    
        - em.persist(-); // 영속화시키는 것  -> DB에 저장하겟다. 
    
- ### 테이블, 컬럼명 생성 전략
    - 카멜 케이스  -> 언더스코어 (memberPoint -> member_point)
    - .(점) -> _(언더스코어)
    - 대문자 -> 소문자
    
    < 논리명 생성(ImplicitNamingStrategy)>  : 테이블 이나 컬럼명을 명시하지 않을 때 논리명 적용
                                                                                                                         
    <물리명 생성(physical-strategy)> : 모든 논리명에 적용됨, 실제 테이블에 적용 (username -> usernm ) 
                                                                                                
   
   ## 애플리케이션 아키텍쳐
   
  - #### 계층형 구조 사용
    - controller , web : 웹 계층
    - service : 비즈니스 로직, 트랜잭션 처리
    - repository : JPA 를 직접 사용하는 계층, 엔티티 매니저 사용
    - domain : 엔티티가 모여 있는 계층 , 모든 계층에서 접근 및 사
    - #### 단방향 구조 : Controller -> Service -> Repository -> DB  
        - (Controller 에서 Repository 바로 접근 가능)                                                                                                                                                                                                                                                                        